# 3.5 Sessions

session是两个正在通信的端节点（endpoint）之间协议关系（protocol relationship），其中包含了与通信所必须的、共享的端节点信息。通信两端中的每一端都至少包含以下上下文信息：

* TS_RX： 从远端接收到的最后一个时间戳（timestamp）；
* TS_RX_TIME： TS_RX发生变化的时间；
* TS_ECHO_TX： 最后一次将时间戳回响（timestamp echo）发送到远端节点的时间；
* MRTO： 检测出的重传超时时间；
* ETRO： 有效果的重传超时时间；
* 对数据包进行加解密，以及根据密码系统设定（Cryptography Profile）检查数据包有效性所需的加解密密钥；
* 加密的远端、近端场景，根据密码系统设定，近端场景是远端节点的远端场景，反之亦然；
* 远端节点的证书
* receive session标识符，由远端节点使用，发送数据包到本节点；
* send session标识符，用于发送数据包到远端节点；
* DESTADDR：远端节点的socket地址；
* 所有正在发送消息的流的上下文配置信息（参见 [3.6.2][1]）；
* 所有正在接收消息的流的上下文配置信息（参见 [3.6.3][2]）；
* 传输成本（transmission budget），用于控制发送数据到网络的速率（例如，拥塞窗口congestion window）；
* S_OUTSTANDING_BYTES： 未接收完的、或还在网络中传输的用户消息数据（user message data）的总量；即某个session直接哦那个每个发送流（sending flow）的F_OUTSTANDING_BYTES的总和；
* RX_DATA_PACKETS： 自动发送了最后一个确认消息后，接收到的、至少包含一个用户数据（User Data）块的数据包的数量，初始值为0；
* ACK_NOW： 布尔值，指明是否应该立即发送确认消息，初始值为false
* DELACK_ALARM： 在延迟一段时间后，会触发一个发送确认消息的动作的警告，初始值为unset；
* 以下几种状态与状态值：
    * opening状态： S_IHELLO_SENT, S_KEYING_SENT
    * open状态   ： S_OPEN
    * closing状态： S_NEARCLOSE, S_FARCLOSE_LINGER
    * closed状态 ： S_CLOSED, S_OPEN_FAILED
* 当前session中本节点的角色，Initiator或Responder

>注意
>
>下面的示意图仅仅是状态转换及相关事件的简述，并不是完整的操作规范。

![Figure 8: Session state diagram][3]

Figure 8: Session state diagram

## 3.5.1 Startup

### 3.5.1.1 Normal Handshake

RTMFP的session是经过两回合共4次握手建立的。为了找到目标端节点，Initiator会发送`IHello`消息给一个或多个候选地址。Responder会无状态的发送`RHello`作为响应。Initiator会以接收到的第一个正确响应的`RHello`的发送者作为目标端节点，并忽略其他端节点。Initiator会计算自己那部分的`session keying`，并发送`IIKeying`。Responder接收到`IIKeying`，如果通过校验，则自算自己那部分的`session keying`和session场景。然后，Responder会创建一个新的`S_OPEN`状态的session，并发送`RIKyeing`。Initiator接收到`RIKeying`，如果通过校验，则计算共享的`session keying`和session场景，并将session的状态置为`S_OPEN`

![Figure 9: Normal handshake][4]

Figure 9: Normal handshake

下面的小节中从Initiator和Responder的角度详细描述了握手的细节。

#### 3.5.1.1.1 Initiator

Initiator决定了何时需要与EPD（Endpoint）Discriminator）建立session。Initiator为建立session做准备，设置状态，并开始与包含了至少一个地址的候选端节点集合进行通信。新session的状态置为`S_IHELLO_SENT`。

如果在打开session的超时时间结束之前，seesion的状态没有切换到`S_OPEN`的话，本次建立session的活动失败，并将状态切换到`S_OPEN_FAILED`。超时时间 *应该* 是95秒。

Initiator需要为这个新开大的session选择一个新的、没有被当前已经打开的session使用过的`Tag`。`Tag` *应该* 应该是经过伪随机数加密的，而且其长度 *不应该* 小于8个字节。然后，Initiator使用EPD和Tag创建一个`IHello`数据块（参见 [2.3.2][5]）。


当Initiator的session处于`S_IHELLO_SENT`状态时，它会将`IHELLO`发到候选集中的每个EPD地址。

如果Initiator接收到一个`Redirect`数据块（参见 [2.3.5][6]），并且其中所带有的`Tag Echo`与当前session的`Tag`匹配，该session也处于`S_IHELLO_SENT`状态，则如果候选端节点地址集中的数目少于`REDIRECT_THRESHOLD`所定义的数目，则将`Redirect`数据库中的重定向地址添加到候选地址集中。`REDIRECT_THRESHOLD`的值 *不应该* 大于24。

如果Initiator接收到一个`RHello`数据块（参见 [2.3.4][7]），并且其中所带有的`Tag Echo`与当前session的`Tag`匹配，该session处于`S_IHELLO_SENT`状态，而且Responder的证书与期望的相匹配，也按照密码系统设定通过了认证，则：

1. 如果Responder的证书的 *Canonical EPD* 与另一个已存在的、处于`S_KEYING_SENT`或`S_OPEN`状态的session的 *Canonical EPD* 匹配，并且另一个已打开的session的证书与期望的EPD相匹配，则该session是重复的， *应该* 被废弃掉，使用那个已经存在的；否则，参见第2条；
2. 将该session置为`S_KEYING_SENT`状态。将`DESTADDR`——远端节点地址——设置为该`RHELLO`数据块的来源地址。Initiator选择一个新的、没有被其他任何ression使用过的、唯一的ID，以便Responder发送数据包给Initiator。它会根据密码系统设定，通过Responder的证书据算出`Session Key Initiator Component`。使用`Session Key Initiator Component`和`RHello`数据块中的cookie，Initiator需要创建`IIKeying`数据块（参见 [2.3.7][8]）。

当Initiator处于`S_KEYING_SENT`状态是，它会发送`IIKeying`发送给`DESTADDR`。

如果Initiator接收到的数据包中含有当前session的标识符，并且其中含有一个`RIKeying`数据块（参见 [2.3.8][9]），并且该session处于`S_KEYING_SENT`状态，并且数据块的签名能够通过使用远端节点的证书（来自`RHello`数据块）进行的校验，并且`Session Key Responder Component`、`Session Key Initiator Component`、近端节点证书和远端节点证书按照密码系统设定（Cryptography Profile）绑定到一起，形成共享session密钥（shared session keys）和场景（nonce），则表明session开启成功。让后将session的状态置为`S_OPEN`。使用`RIKeying`的内容设置 *send session identifier*。此后，数据包的加解密和校验都是用新计算出的共享session密钥（shared session key）完成，session也可以交由用程序使用了。

[1]:    ./3.6.2_Sender.md
[2]:    ./3.6.3_Receiver.md
[3]:    ../images/figure-8.jpg
[4]:    ../images/figure-9.jpg
[5]:    ../2_Syntax/2.3.2_Initiator_Hello_Chunk.md
[6]:    ../2_Syntax/2.3.5_Responder_Redirect_Chunk.md
[7]:    ../2_Syntax/2.3.4_Responder_Hello_Chunk.md
[8]:    ../2_Syntax/2.3.7_Initiator_Initial_Keying_Chunk.md
[9]:    ../2_Syntax/2.3.8_Responder_Initial_Keying_Chunk.md
