# 3.5 Sessions

session是两个正在通信的端节点（endpoint）之间协议关系（protocol relationship），其中包含了与通信所必须的、共享的端节点信息。通信两端中的每一端都至少包含以下上下文信息：

* TS_RX： 从远端接收到的最后一个时间戳（timestamp）；
* TS_RX_TIME： TS_RX发生变化的时间；
* TS_ECHO_TX： 最后一次将时间戳回响（timestamp echo）发送到远端节点的时间；
* MRTO： 检测出的重传超时时间；
* ETRO： 有效果的重传超时时间；
* 对数据包进行加解密，以及根据密码系统设定（Cryptography Profile）检查数据包有效性所需的加解密密钥；
* 加密的远端、近端场景，根据密码系统设定，近端场景是远端节点的远端场景，反之亦然；
* 远端节点的证书
* receive session标识符，由远端节点使用，发送数据包到本节点；
* send session标识符，用于发送数据包到远端节点；
* DESTADDR：远端节点的socket地址；
* 所有正在发送消息的流的上下文配置信息（参见 [3.6.2][1]）；
* 所有正在接收消息的流的上下文配置信息（参见 [3.6.3][2]）；
* 传输成本（transmission budget），用于控制发送数据到网络的速率（例如，拥塞窗口congestion window）；
* S_OUTSTANDING_BYTES： 未接收完的、或还在网络中传输的用户消息数据（user message data）的总量；即某个session直接哦那个每个发送流（sending flow）的F_OUTSTANDING_BYTES的总和；
* RX_DATA_PACKETS： 自动发送了最后一个确认消息后，接收到的、至少包含一个用户数据（User Data）块的数据包的数量，初始值为0；
* ACK_NOW： 布尔值，指明是否应该立即发送确认消息，初始值为false
* DELACK_ALARM： 在延迟一段时间后，会触发一个发送确认消息的动作的警告，初始值为unset；
* 以下几种状态与状态值：
    * opening状态： S_IHELLO_SENT, S_KEYING_SENT
    * open状态   ： S_OPEN
    * closing状态： S_NEARCLOSE, S_FARCLOSE_LINGER
    * closed状态 ： S_CLOSED, S_OPEN_FAILED
* 当前session中本节点的角色，Initiator或Responder

>注意
>
>下面的示意图仅仅是状态转换及相关事件的简述，并不是完整的操作规范。

![Figure 8: Session state diagram][3]

Figure 8: Session state diagram

## 3.5.1 Startup

### 3.5.1.1 Normal Handshake

RTMFP的session是经过两回合共4次握手建立的。为了找到目标端节点，Initiator会发送`IHello`消息给一个或多个候选地址。Responder会无状态的发送`RHello`作为响应。Initiator会以接收到的第一个正确响应的`RHello`的发送者作为目标端节点，并忽略其他端节点。Initiator会计算自己那部分的`session keying`，并发送`IIKeying`。Responder接收到`IIKeying`，如果通过校验，则自算自己那部分的`session keying`和session场景。然后，Responder会创建一个新的`S_OPEN`状态的session，并发送`RIKyeing`。Initiator接收到`RIKeying`，如果通过校验，则计算共享的`session keying`和session场景，并将session的状态置为`S_OPEN`

![Figure 9: Normal handshake][4]

Figure 9: Normal handshake

下面的小节中从Initiator和Responder的角度详细描述了握手的细节。

#### 3.5.1.1.1 Initiator

Initiator决定了何时需要与EPD（Endpoint）Discriminator）建立session。Initiator为建立session做准备，设置状态，并开始与包含了至少一个地址的候选端节点集合进行通信。新session的状态置为`S_IHELLO_SENT`。

如果在打开session的超时时间结束之前，seesion的状态没有切换到`S_OPEN`的话，本次建立session的活动失败，并将状态切换到`S_OPEN_FAILED`。超时时间 *应该* 是95秒。

Initiator需要为这个新开大的session选择一个新的、没有被当前已经打开的session使用过的`Tag`。`Tag` *应该* 应该是经过伪随机数加密的，而且其长度 *不应该* 小于8个字节。然后，Initiator使用EPD和Tag创建一个`IHello`数据块（参见 [2.3.2][5]）。


当Initiator的session处于`S_IHELLO_SENT`状态时，它会将`IHELLO`依次发到候选集中的每个EPD地址，按不同的发送顺序要计算补偿（backoff）时间。补偿时间的增量值 *不应该* 是等比增加的，而每次增加的补偿时间也 *不应该* 少于1.5秒。对每个候选地址来说，补偿时间都应该单独计算，因为随着时间推移，候选地址集中可能会添加新的地址。

如果Initiator接收到一个`Redirect`数据块（参见 [2.3.5][6]），并且其中所带有的`Tag Echo`与当前session的`Tag`匹配，该session也处于`S_IHELLO_SENT`状态，则如果候选端节点地址集中的数目少于`REDIRECT_THRESHOLD`所定义的数目，则将`Redirect`数据库中的重定向地址添加到候选地址集中。`REDIRECT_THRESHOLD`的值 *不应该* 大于24。

如果Initiator接收到一个`RHello`数据块（参见 [2.3.4][7]），并且其中所带有的`Tag Echo`与当前session的`Tag`匹配，该session处于`S_IHELLO_SENT`状态，而且Responder的证书与期望的相匹配，也按照密码系统设定通过了认证，则：

1. 如果Responder的证书的 *Canonical EPD* 与另一个已存在的、处于`S_KEYING_SENT`或`S_OPEN`状态的session的 *Canonical EPD* 匹配，并且另一个已打开的session的证书与期望的EPD相匹配，则该session是重复的， *应该* 被废弃掉，使用那个已经存在的；否则，参见第2条；
2. 将该session置为`S_KEYING_SENT`状态。将`DESTADDR`——远端节点地址——设置为该`RHELLO`数据块的来源地址。Initiator选择一个新的、没有被其他任何ression使用过的、唯一的ID，以便Responder发送数据包给Initiator。它会根据密码系统设定，通过Responder的证书据算出`Session Key Initiator Component`。使用`Session Key Initiator Component`和`RHello`数据块中的cookie，Initiator需要创建`IIKeying`数据块（参见 [2.3.7][8]）。

当Initiator处于`S_KEYING_SENT`状态是，它会发送`IIKeying`发送给`DESTADDR`，并计算补偿时间，每次尝试之间的时间间隔的增量值 *不应该* 是等比增加的，也 *不应该* 少于1.5秒。

如果Initiator接收到的数据包中含有当前session的标识符，并且其中含有一个`RIKeying`数据块（参见 [2.3.8][9]），并且该session处于`S_KEYING_SENT`状态，并且数据块的签名能够通过使用远端节点的证书（来自`RHello`数据块）进行的校验，并且`Session Key Responder Component`、`Session Key Initiator Component`、近端节点证书和远端节点证书按照密码系统设定（Cryptography Profile）绑定到一起，形成共享session密钥（shared session keys）和场景（nonce），则表明session开启成功。让后将session的状态置为`S_OPEN`。使用`RIKeying`的内容设置 *send session identifier*。此后，数据包的加解密和校验都是用新计算出的共享session密钥（shared session key）完成，session也可以交由用程序使用了。

<a name="3.5.1.1.2">
#### 3.5.1.1.2 Responder

在接收到带有EPD自身标识的`IHello`数据块（参见 [2.3.2][5]）后，端节点 *应该* 构建一个`RHello`数据块（参见 [2.3.4][7]），并将之发回给`IHello`数据包的发送源。为了避免潜在的因资源耗尽而导致DoS的风险，端节点 *不应该* 创建持久状态的`IHello`。端节点在为`RHello`生成 *cookie* 时，*必须* 保证该 *cookie* 在经由`IIKeying`传回时，可能被正确的解码并通过校验。端节点 *应该* 使用`IHello`数据块的发送源的地址作为生成 *cookie* 的一个参数。*cookie* *应该* 是有有效期限制的，其生命周期 *不应该* 少于95秒（建议与session打开的超时时间相同）。

在从Forwarder（参见 [3.5.1.5][10]）处接收到`FIHello`数据块（参见 [2.3.3][11]）后，端节点 *应该* :

1. 把`FIHello`当做从`IHello`，并计算、构建、发送`RHello`;或者
2. 构建一个`Implied Redirected`数据块（参见 [2.3.5][6]），将之发送到`FIHello`的发送源地址；或者
3. 无视该`FIHello`数据块

在接收到`IIKeying`数据块（参见 [2.3.7][8]）后，如果其中的 *cookie* 未通过校验或已经过期，则无视之。

如果 *cookie* 通过校验，但是与`IIKeying`数据块的发送源地址不匹配，则需要执行专门的 *Cookie Change* （参见 [3.5.1.2][12]）处理。

接收到`IIKeying`数据块，其 *cookie* 有效且能够通过验证，如果证书是按照密码系统设定（Cryptography Profile）经过验证的，而且数据块中的签名也是可以用远端节点的证书和密码系统设定进行验证的，而且`Session Key Initiator Component`也是可接受的，则有以下几种情况：

1. 如果数据块`IIKeying`的发送源地址与某个已打开的、处于`S_IHELLO_SENT`或`S_KEYING_SENT`状态的session相关联，则执行 *Glare* （参见 [3.5.1.3][13]）操作;
2. 如果数据块`IIKeying`的发送源地址与某个处于`S_OPEN`状态的session相关联，则有以下几种情况：
    * 如果接收者处于`S_OPEN`状态的session中的Responder，而且session标识符、证书和`Session Key Initiator Component`都与那个处于`S_OPEN`状态的session相同，则这个`IIKeying`数据块是一个重传（retransmission）标识。因此，需要想下文描述的一样，使用`Default Session Key`重新发送这个处于`S_OPEN`状态的session的`RIKeying`数据块；
    * 如果该`IIKeying`数据块的证书与当前处于`S_OPEN`状态的session的证书不匹配，则忽略该`IIKeying`数据块；
    * 如果该`IIKeying`数据块的证书能覆盖（override）当前处于`S_OPEN`状态的session的证书，说明这是一个新打开的session，只不过使用的是已存在的session标识符，而原先的那个session已经失效了。此时需要将已存在的session的状态置为`S_CLOSE`，将其中所有的数据流都退出（给用户发送异常信号），然后继续执行对`IIKeying`数据块的处理；
3. 计算`Session Key Responder Component`，选择一个新的、唯一的、还没有被其他任何session使用过的session标识符，供Initiator给Responder发送数据包时使用。使用该数据和`Session Key Initiator Component`构建`RIKeying`数据块（参见 [2.3.8][9]），并对之签名。将`Session Key Initiator`、`Responder Components`、近端节点证书、远端节点证书和Responder绑定，并依据密码系统设定（Cryptography Profile）计算共享session密钥（shared session keys）和相关场景。Responder创建一个处于`S_OPEN`状态的、新的session，设置远端节点地址——DESTADDR——为`IIKEYing`数据块的发送源地址，设置发送方session标识符（the send session identifier）为接收到`IIKeying`数据块的session标识符。Responder发送包含了`Default Session Key`和请求的发送方session标识符（send session identifier）`RIKeying`数据块给Initiator。然后，该session中后续的数据包加解密、校验都会使用新生成的密钥来处理，而这个session也可以正式交给上层应用程序使用了。

### 3.5.1.2 Cookie Change

在某写情况下，Responder用来生成`RHello`数据块中 *cookie* 的Initiator的地址与Initiator直接给Responder发送数据包时的地址不同。这是有可能会发生的，例如，Initiator有多个本地地址，一个与Forwarder连接，另一个与Responder连接。

![Handshake with Cookie Change][15]

考虑下面这个案例：

Initiator有两个网络接口，第一个接口的地址是`Ix = 192.0.2.100:50000`，第二个借口的地址是`Iy = 198.51.100.101:50001`。Responder有一个接口，与Initiator的第二个借口处于同一网络中，地址是`Ry = 198.51.100.200:51000`。Initiator使用第一个网络接口连接Forwarder。Forwarder监视Initiator的`Ix`接口，并发送`Forwarded IHello`（参见 [2.3.3][11]）数据块给Responder。Responder会将这个`Forwarded IHello`数据块当作是从Initiator的`Ix`接口发来的`IHello`数据块来处理，计算相关的cookie，并发送`RHello`数据块给Initiator的`Ix`接口。Initiator接收到来自Responder的`Ry`接口的`RHello`数据块，并选择该地址作为session通信的目标地址。然后，Initiator会从`RHello`数据块中拷贝一份cookie，并发送`IIKeying`数据块给Responder。但是，由于`RHello`数据块的发送是Reponder的`Ry`接口，并不是Initiator直接连接的，所以Initiator会使用其第2个网络接口`Iy`来发送`IIKeying`数据块。Responder在接收到`IIKeying`数据块后，会比较数据块中的 *cookie* 与基于数据包源地址计算出的期望值相比较，而且如果`IIKeying`源地址与用来生成 *cookie* 的`IHello`数据块源地址不匹配的，Responder要拒绝该`IIKeying`数据块。

如果Responder判断出，通过`IIKeying`数据块生成的 *cookie* 与发送者地址不匹配（例如，如果cookie分为两部分，第一部分由Initiator的地址独立的计算出来，第二部分依赖于地址（a second part dependent on the address）），Responder *应该* 基于`IIKeying`数据块发送源地址生成一个新的cookie，并基于`IIKeying`数据块的session标识符和`Default Session Key`生成`RHello Cookie Change`（参见 [2.3.6][16]）数据块并发送到`IIKeying`数据块的发送源地址。

如果Initiator从一个处于`S_KEYING_SENT`状态的session接收到`RHello Cookie Change`数据块，而且旧的 *cookie* 最初发送给Responder的相匹配，则Initiator会接收使用新的 *cookie* ，生成一个新的`IIKeying`数据块并签名，再将之发送给Responder。 Initiator *应该* 只能给为某个session变更一次cookie。

### 3.5.1.3 Glare

当两个端节点都试图与对方初始化session时，就会出现 *Glare* 现象。当从一个已经打开的session的接收方的接收到有效的、能通过认证的`IIKeying`数据块时，也被认为是 *Glare* 现象。在一对端节点之间仅能建立一个session。

可以将接收到的`IIKeying`数据块中的证书与近端节点的证书相比较，以此来解决 *Glare* 现象。在密码系统设定（Cryptography Profile）中定义了证书比较函数来决定到底哪一端是Initiator。

如果近端节点胜出，则抛弃、忽略`IIKeying`数据块。远端节点要终止要从近端节点接收`IIKeying`数据块的session。

如果远端节点胜出，则有以下几种情况：

1. 如果`IIKeying`数据块中的证书能够依据密码系统设定（Cryptography Profile）覆盖近端节点中正准备打开的session的证书，则终止并销毁近端节点的这个正准备打开的session；
2. 继续执行正常的`Responder IIKeying`（参见 [3.5.1.1.2][13]）的处理流程。

### 3.5.1.4 Redirector

![Redirector][14]

Redirector就好象是EPD（Endpoint Discriminators）的DNS。Initiator *可能会* 使用Redirector来获取更多的候选端节点，以便找到建立session所需的合适远端节点。

如果接收到一个`IHello`数据块，而且其中的EPD并没有选择Redirector的标识，则Redirector需要构建一个包含了一个或多个候选端节点地址的`Responder Redirect`数据块（参见 [2.3.5][6]），并将之发回给Initiator。

![Redirector][17]

注意：Redirector *不应该* 与将Redirector作为其他端节点的候选节点的节点建立session连接，因为远端节点可能会将Redirector的`IIKeying`数据块看成是远端节点与另一个节点发生了 *Glare* 现象。 

[1]:    ./3.6.2_Sender.md
[2]:    ./3.6.3_Receiver.md
[3]:    ../images/figure-8.jpg
[4]:    ../images/figure-9.jpg
[5]:    ../2_Syntax/2.3.2_Initiator_Hello_Chunk.md
[6]:    ../2_Syntax/2.3.5_Responder_Redirect_Chunk.md
[7]:    ../2_Syntax/2.3.4_Responder_Hello_Chunk.md
[8]:    ../2_Syntax/2.3.7_Initiator_Initial_Keying_Chunk.md
[9]:    ../2_Syntax/2.3.8_Responder_Initial_Keying_Chunk.md
[10]:   ./3.5.1.5_Forwarder.md
[11]:   ../2_Syntax/2.3.3_Forwarded_Initiator_Hello_Chunk.md
[12]:   ./3.5.1.2_Cookie_Change.md
[13]:   #3.5.1.1.2
[14]:   ../images/figure-11.jpg
[15]:   ../images/figure-10.jpg
[16]:   ../2_Syntax/2.3.6_RHello_Cookie_Change_Chunk.md
[17]:   ../images/figure-12.jpg
