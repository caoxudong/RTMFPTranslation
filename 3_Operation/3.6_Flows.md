# 3.6 流（Flows）

流是session中用于传输一系列用户消息的单向通信通道。session的两端都可以有0个或多个指向对方的发送流。每个发送流都有在另一端有一个对应的接收流。

## 3.6.1 概述

### 3.6.1.1 标识（Identity）

session的多个流之间是通过流标识符（flow identifier）来区分的。session的每一端都可以独立为流选择流标识符，即便两端选择了类似的流标识符，也并不意味它们之间有关联关系。发送方 *可能会* 给任意一个流选择任意一个流标识符，因此流的接收方 *禁止* 基于流标识符来推测任何语义、角色或命名。规范中没有将任何流标识符规定为 *保留的（reversed）* ，也没有任何约定俗成的流标识符。

流的双向关联关系会在建立流的时候由`Return Flow Association`选项（参见 [2.3.11.1.2]）指明。一个端节点可以指定一个新的发送流（sending flow）来响应来自session另一端的接收流（receiving flow）。发送流 *必须* 最多只能与一个接收流建立关联关系；接收流则可以与任意个发送流建立关联关系。在整个发送流的生命周期内，`Return Flow Association`（如果存在的话）是固定不变的。注意，关联关系中的一个流关系并不自动关闭与之关联的其他流，这其中的例外情况参见 [3.6.3.1][3]中的描述。

流可以用任何用户元数据来命名。在本规范中，除了编码后的大小（参见 [2.3.11.1.1.][2]）之外，并没有对用户元数据做任何有关编码、语法或语义的规定；用户元数据由应用程序管理。在流的整个生命周期内，用户元数据是不变的。

### 3.6.1.2 消息与序列（Messages and Sequencing）

流（flow）提供了面向消息（message-oriented）的帧（framing）。为了便于在网络中传输，提交较大的信息会被分片发送。接收者需要将分片的消息重新整合为一个整体，然后再将之呈现给用户。

发送者通过发送流（sending flow）按顺序将分片的消息发送出去。由于在传输过程可能会出现丢失和重传，所以接收者接收到的分片消息可能是乱序的，因此接收者需要将接收到的消息按照原本的顺序重新整合为一个整体。流是顺序发送消息的基本单元；每个流的发送顺序都是独立于其他流的；流之间对消息到达和发送顺序不做任何保证。

流顺序发送的独立性使得发送者可以将session中发送或重传某个消息的流设定为具有比其他流更高的优先级。RTMFP将流设计为评定优先级的基本但与那。在任意流中，分片序号（fragment sequence number）是唯一且单调递增的，即消息的分片序号 *必须* 比所有该流中所有以入队的消息的分片序号大。接收方在接收到分片的消息时可能会造成不连续的断档，接收方就需要对每个接收到的数据包发送确认消息。因此，对任意流来说，发送者 *应该* 先发送具有较小分片序号的分片。

发送者可以在任意时间放弃某个已经入队的消息，即使接收者已经收到了该消息的某些分片。接收者 *必须* 能够检测到由于消息被废弃而造成的断档；因此，在消息分片中，即使该消息的一个分片都没发送，每个消息也都 *应该* 至少使用一个分片序号。发送方会发送未被废弃的所有消息的所有分片，直到未被废弃的所有小的所有分片都得到了接收方的确认。发送方会发送一个`Forward Sequence Number(FSN)`数据块给接收方，声明“会发送或重传小于等于FSN的分片序号指定的消息分片。“这种机制使得接收方可以跳过消息分片的断档，继续接受消息分片，再整合为一个整体交给用户。如果某个消息中的某些分片已经丢失，并且这些丢失的分片的分片序号比FSN小，则发送方会废弃掉这条消息，接收方也就无法将之重组为一个完整的信息了。发送方 *必须* 通知接收方出现了断档。

### 3.6.1.3 生命周期（lifetime）

发送方发送用户消息分片（包括用户元数据和`Return Flow Association`（如果存在的话））给接收方标志着流的开始，此后发送方发送的消息分片中也一直会包含用户元数据和`Return Flow Association`（如果存在的话），直到接收方确认了这个流的建立，此时发送方孩子到接收到已经获取到了用户元数据和`Return Flow Association`（如果存在的话）。此时，流标识符（flow identifier）建立完成。

无论接受还是拒绝某个流，流的接收方 *应该* 对所有接收到的分片序号做确认。在没有接收到指定的`FSN`时，流的接收者 *禁止* 对大于`FSN`的分片序号做确认。对分片序号的确认使拥塞控制（congestion control）和避障算法（avoidance algorithms）更加准确。

在流的生命周期内，端节点可以在任意时间拒绝接受某个流。为了拒绝这个流，接收方需要在发送确认数据块之前，立即发送`Flow Exception`数据块（参见 [2.3.16]）。

最终，端节点可能会终端发送流。流的最后一个分片序号会被添加`Final`标记。当流中所有的分片序号，包括带有`Final`标记的最后一个分片序号，都被接收方确认之后，发送流就结束了。当从`FSN`到带有`Final`标记的分片序号都收到之后，接收流结束。为了保证网络中的消息分片发送完成（因为可能有延迟和重发），无需重新建立发送流和接收流， 发送流和对应的接收流都会将流标识符保存一段时间。

如果发送方收到`Flow Exception`数据块，发送方 *应该* 关闭流，废弃所有已入队但还未发送的消息。发送方 *应该* 通知用户出现了“流中断”的情况。


## 3.6.2 发送方（Sender）

发送方握有该流与接收方通信的必要的上下文信息，至少包括：

* F_FLOW_ID: 流标识符
* STARTUP_OPTIONS: 保存发送给接收方的选项集，直到接收方对这个流进行确认。选项集中包括`User's Per-Flow Metadata`和`Return Flow Association`（如果存在的话）；
* SEND_QUEUE: 流中已入队的、但还未得到接收方确认的消息分片，初始为空；每个消息分片都包括：
    * SEQUENCE_NUMBER: 该消息分片的分片序号；
    * DATA: 分片中的用户数据；
    * FRA: 消息分片中的分片控制值，其可选值参见 [2.3.11][6]；
    * ABANDONED: 布尔值，指明该消息分片是否被废弃；
    * SENT_ABANDONED: 布尔值，执行该消息分片在发送时是否被废弃；
    * EVER_SENT: 布尔值，指明该分片是否已经被发送过（至少一次），初始为false；
    * NAK_COUNT: 检测到的该分片的负确认（negative acknowledgement）的次数，初始为0；
    * IN_FLIGHT:布尔值，指明该分片是否正在传输过程中，初始为false；
    * TRANSMIT_SIZE: 当该分片被传输到网络中后，分片中经过编码的`User Data`数据块（包括数据头）的大小，单位为字节；
* F_OUTSTANDING_BYTES: `SEND_QUQUE`中`IN_FLIGHT`域为true的元素的`TRANSMIT_SIZE`域的值之和；
* RX_BUFFER_SIZE: 最近可用的缓冲区大小，参见[2.3.13][7]和[2.3.14][8]，初始值为65536；
* NEXT_SN: 要为下一消息分片的分片序号赋予的值，初始值为1；
* F_FINAL_SN: 要赋予带有`Final`标记的消息分片的分片序号，初始值为空；
* EXCEPTION: 布尔值，指明是否从接收方接收到异常报告，初始值为false；
* 状态，任意时间内，其值为以下之一：`F_OPEN`（已打开），`F_CLOSING`与`F_COMPLETE_LINGER`（正在关闭），`F_CLOSED`（已关闭）。

注意：下面的示意图并不是完整的操作规范，只是状态转换的见图。

![Figure 19: Sending flow state diagram][5]

### 3.6.2.1 建立（Startup）

在处于`S_OPEN`状态的session中，应用程序可以建立一条指向接收方的发送流。此时需要为这个流选择一个从未被指给该session中的处于`F_OPEN`、`F_CLOSING`或`F_COMPLETE_LINGER`状态的其他流的流标识符。流开始时是`F_OPEN`状，并在`User's Per-Flow Metadata`（参见 [2.3.11.1.1][2]）中设置`STARTUP_OPTIONS`。如果新建的发送流要给接收方发送响应，则需要将流标识符编码到`Return Flow Association`数据块（参见 [2.3.11.1.2][1]）中，并添加到`STARTUP_OPTIONS`中。在响应而来自session另一端的、在发送流被打开时不是`RF_OPEN`状态的接收流时，发送流 *不应该* 是打开状态的。

此时，流存在于发送方，而不是在接收方。当开始传输用户数据片段（user data fragment）时，流正式建立完成。在没有用户数据时，发送者可以通过发送`Forward Sequence Number Update`数据块（参见 [3.6.2.7.1][9]），即入队并传输已经废弃的用户数据片段来开启一个流。

### 3.6.2.2 入队数据（Queuing Data）

为了将消息传输到远端，应用程序需要将消息入队，放入到`F_OPEN`状态的发送流中。RTMFP实现要将每个消息分解为一个或多个`User Data`数据块（参见 [2.3.11][6]）。每个分片 *必须* 足够小，这样在组合成数据包（包括最大通用头（maximum-size common header）、`User Data`数据块的头和流的`STARTUP_OPTIONS`（如果存在的话））后才不会超过`Path MTU`（参见 [3.5.4.3][10]）的限制。

对每个分片来说，创建一个分片项（fragment entry），并这是`fragmentEntry.SEQUENCE_NUMBER`域的值为`flow.NEXT_SN`，再将`flow.NEXT_SN`的值加1.根据`User Data`数据块中的编码，设置`fragmentEntry.FRA`域的值：

   0: 该分片是一个完整的信息
   1: 该分片是具有多个分片的消息的第一个分片
   2: 该分片是具有多个分片的消息的最后一个分片
   3: 该分片是具有多个分片的消息的中间某个分片
   
将`fragmentEntry`添加到`flow.SEND_QUEUE`。

<a name="3.6.2.3" />
### 3.6.2.3 发送数据（Sending Data）

如果`SEND_QUEUE`中至少包含一个合格、可发送的元素，且如果`RX_BUFFER_SIZE`大于`F_OUTSTANDING_BYTES`，或者`EXCEPTION`的值为true的话，表明该流已经可以发送数据了。

如果`IN_FLIGHT`的值为false，且以下3条至少满足一个，则表示`SEND_QUEUE`中的元素可以发送了：

1. 该元素的`ABANDONED`域的值为false；
2. 该元素是`SEND_QUEUE`队列中的第一个元素；
3. 该元素的`SEQUENCE_NUMBER`域的值等于`flow.F_FINAL_SN`域的值。

如果session的传输预算（transmission budget）允许，则根据具体实现设定的优先级规则，选择一个准备发送数据流。本规范中并未对优先级的设定做规定。

从队列的前段剔除被废弃的消息，找到`Forwarded Sequence Number(FSN)`：

1. 如果`SEND_QUEUE`中包含至少两个元素，而且第一个元素的`IN_FLIGHT`域为false，`ABANDONED`域为true，则从`SEND_QUEUE`中剔除第一个元素；
2. 如果`SEND_QUEUE`中第一个元素的`ABANDONED`域为false，设置`FSN`的值为`entry.SEQUENCE_NUMBER - 1`；否则
3. 如果`SEND_QUEUE`中第一个元素的`IN_FLIGHT`域为true，`entry.SENT_ABANDONED`域为false，则设置`FSN`的值为`entry.SEQUENCE_NUMBER - 1`；否则
4. 如果`SEND_QUEUE`中第一个元素的`ABANDONED`域为true，并且`IN_FLIGHT`域为false或者在发送时已经把`ABANDONED`置为true，则设置`FSN = entry.SEQUENCE_NUMBER - 1`。

*禁止* `FSN`大于任何当前正在传输的分片的分片序号。*禁止* `FSN`等于任何在发送时`ABANDONED`域为false，目前正在传输过程中的分片的分片序号。

将流中的用户数据块组合为一个完成数据包发送给接收方。如果数据包中的空间够大，而且流也准备好发送了，则：

1. 从`SEND_QUEUE`的头开始，找到一给合格的、可以发送的元素；
2. 将待发送元素编码为`User Data`数据块（参见 [2.3.11][6]），或者`Next User Data`数据块（参见 [2.3.12][12]）（如果可能的话，参见 [3.6.2.3.2][11]）；
3. 如果有，则设置`chunk.flowID = flow.F_FLOW_ID`；
4. 如果有，则设置`chunk.sequenceNumber = entry.SEQUENCE_NUMBER`；
5. 如果有，则设置`chunk.fsnOffset = entry.SEQUENCE_NUMBER - FSN`；
6. 设置`chunk.fragmentControl = entry.FRA`；
7. 设置`chunk.abandon = entry.ABANDONED`；
8. 如果`entry.SEQUENCE_NUMBER == flow.F_FINAL_SN`，则设置`chunk.final = true`；否则，设置`chunk.final = false`；
9. 如果有Option与该数据块一起发送，则设置`chunk.optionsPresent = true`，将Option整合入数据块，并使用一个`Marker`标记Option列表结束；
10. 如果`entry.ABANDONED == true`，则设置`chunk.userData`为空；否则，设置`chunk.userData = entry.DATA`;
11. 如果将组合后的数据块添加到数据包中会使数据包的大小超过`Path MTU`，则取消将数据块整合到数据包的计划，确保数据包中有足够的空间；否则，继续往下做；
12. 设置`entry.IN_FLIGHT = true`；
13. 设置`entry.EVER_SENT = true`；
14. 设置`entry.NAK_COUNT = 0`；
15. 设置`entry.SENT_ABANDONED = entry.ABANDONED`；
16. 设置`entry.TRANSMIT_SIZE`域的值为整合后数据块的大小（包含数据块的头部内容）；
17. 将该数据块整合到数据包中；
18. 如果该流或该元素是时间敏感的（Time Critical）或具有实时性的，则将包头（packet header）中的`timeCritical`域设置为`true`。

完成其他的数据包处理过程，并发送之。

#### 3.6.2.3.1 建立选项（Startup Options）

如果`STARTUP_OPTIONS`不为空，那么在将该流中的第一个`User Data`数据块整合到数据包中时，将经过编码的`STARTUP_OPTIONS`添加到数据块的Option列表中。

<a name="3.6.2.3.2" />
#### 3.6.2.3.2 发送后续数据（Send Next Data）

当需要将多个连续的分片整合到一个数据包中时，会使用`Next User Data`数据块。

在将流中的一个用户消息分片整合到数据包中后（参见 [3.6.2.3][13]），如果下一个待整合的消息分片属于同一个流，而且它的分片序号比刚刚整合的那个消息分片的分片序号大，则 *应该* 使用`Next User Data`数据块，而不是`User Data`数据块。

流的第一个消息分片被整合到数据包中时， *必须* 使用`User Data`数据块。

### 3.6.2.4 处理确认（Processing Acknowledgements）

`Data Acknowledgement Bitmap`数据块（参见 [2.3.13][7]）或`Data Acknowledgement Ranges`数据块（参见[2.3.14][8]）中包含了对流中一个或多个分片序号的接收确认，还有接收方当前receive window advertisement。

当从发送流中接收到确认消息后：

1. 设置`PRE_ACK_OUTSTANDING_BYTES = flow.F_OUTSTANDING_BYTES`；
2. 设置`flow.STARTUP_OPTIONS`为空；
3. 设置`flow.RX_BUFFER_SIZE = chunk.bufferBytesAvailable`；
4. 对编码在确认消息中的分片序列，如果`SEND_QUEUE`中某个元素的分片序号与确认消息中的小童，而且该元素的`IN_FLIGHT`域的值为`true`，则将该元素从`flow.SEND_QUEUE`中移除；
5. 通知拥塞控制算法和避障算法：大小为`PRE_ACK_OUTSTANDING_BYTES - flow.F_OUTSTANDING_BYTES`字节的数据已经得到确认。注意，负确认（Negative Acknowledgement，参见 [3.6.2.5][14]）会影响拥塞控制。

<a name="3.6.2.5" />
### 3.6.2.5 负确认与丢失（Negative Acknowledgement and Loss）



<a name="3.6.2.7.1">
#### 3.6.2.7.1

<a name="3.6.3.1" />
### 3.6.3.1

[1]:    ../2_Syntax/2.3_Chunks.md#2.3.11.1.2
[2]:    ../2_Syntax/2.3_Chunks.md#2.3.11.1.1
[3]:    #3.6.3.1
[4]:    ../2_Syntax/2.3_Chunks.md#2.3.16
[5]:    ../images/figure-19.jpg
[6]:    ../2_Syntax/2.3_Chunks.md#2.3.11
[7]:    ../2_Syntax/2.3_Chunks.md#2.3.13
[8]:    ../2_Syntax/2.3_Chunks.md#2.3.14
[9]:    #3.6.2.7.1
[10]:   ./3.5_Sessions.md#3.5.4.3
[11]:   #3.6.2.3.2
[12]:   ../2_Syntax/2.3_Chunks.md#2.3.12
[13]:   #3.6.2.3
[14]:   #3.6.2.5
